# AEX-141: Non-Fungible Token Standard

```
AEX: 141
Title: Non-Fungible Token Standard
Author: Arjan van Eersel <arjan@toqns.com> (@zkvonsnarkenstein), Marco Walz (@marc0olo), Philipp (@thepiwo), Rogerio (@jyeshe)
License: ISC
Discussions-To: https://forum.aeternity.com/t/aeternity-nft-token-standard/9781
Status: Review
Type: Interface
Created: 2021-09-11
```

## Abstract

A standard implementation of non-fungible tokens for the æternity ecosystem. Initially, the design goal of the primary interface was to be as compatible with ERC-721 as possible, so that anyone who can work with ERC-721 can work with this interface. However, specifically when it comes to dealing with metadata a decision was taken to provide contract developers as much flexibility as possible.

Core differences to the well-known ERC-721 standard:
- Unsafe transactions are not supported. Therefore, all transactions are ought to be safe
- Usage of zero-address for minting or burning is avoided. Thus, explicit events for minting and burning have been defined
- Token transfers do not require the (owner) address to be passed. Only the recipient address needs to be provided to the entrypoint
- High flexibility when it comes to dealing with metadata is provided

## Motivation

The following standard describes standard interfaces for non-fungible tokens. The proposal contains a primary interface and secondary interfaces (extensions) for optional functionality that not everyone might need.

# AEX141 NFT

## IAEX141

```sophia
contract interface IAEX141 =
    datatype metadata_type = URL | OBJECT_ID | MAP
    datatype metadata = MetadataIdentifier(string) | MetadataMap(map(string, string))

    record meta_info = 
        { name: string
        , symbol: string 
        , base_url: option(string)
        , metadata_type : metadata_type }

    datatype event 
        = Transfer(address, address, int)
        | Approval(address, address, int, string)
        | ApprovalForAll(address, address, string)

    entrypoint aex141_extensions : () => list(string)

    entrypoint meta_info : () => meta_info

    entrypoint metadata : (int) => option(metadata)

    entrypoint balance : (address) => option(int)

    entrypoint total_supply : () => int

    entrypoint owner : (int) => option(address)
   
    stateful entrypoint transfer : (address, int, option(string)) => unit

    stateful entrypoint approve : (address, int, bool) => unit

    stateful entrypoint approve_all : (address, bool) => unit

    entrypoint get_approved : (int) => option(address)

    entrypoint is_approved : (int, address) => bool

    entrypoint is_approved_for_all : (address, address) => bool
```

## Methods

### aex141_extensions\(\)

**Returns** a hardcoded list of all implemented extensions on the deployed contract.

```sophia
entrypoint aex141_extensions() : list(string)
```

### meta_info\(\)

Returns meta information associated with the contract.

Note:
- The `base_url` is optional and is only intended to be used if the `metadata_type` is `URL`. As known from ERC-721 this can be used to resolve metadata for a specific NFT which can be fetched from an URL based on the token id
- The `metadata_type` MUST be defined on contract level and MUST NOT be mixed across various NFTs in a contract

```sophia
entrypoint meta_info() : meta_info
```

| return | type |
| :--- | :--- |
| meta_info | meta_info |

### metadata\(\)

Returns metadata associated with an NFT.

Note:
- The `metadata` can be set in the constructor, as well as by implementing extensions like e.g. `mintable`
- The `metadata` to use depends on the `metadata_type` defined on contract level and provides certain flexibility:
  - for `URL` and `OBJECT_ID` use `MetadataIdentifier`
      - `URL` can represent any URL and typically the NFT id is used to resolve the metadata using that URL, e.g.
          - `ipfs://` serving as `base_url` and pointing to a folder stored on IPFS where immutable metadata is stored (recommended)
          - `https://` serving as `base_url` and pointing to a traditional website where metadata is stored
          - ...
      - `OBJECT_ID` can be used to refer to any kind of item which typically already exists (e.g. the VIN of a car)
  - for `MAP` use `MetadataMap`
    - `MAP` provides almost unlimited flexibility and allows any kind of metadata to be represented in a map

```sophia
entrypoint metadata(token_id: int) : option(metadata)
```

| parameter | type |
| :--- | :--- |
| token_id | int |

| return | type |
| :--- | :--- |
| data | option(metadata) |

### total_supply\(\)

Returns the total amount of NFTs in circulation.

```sophia
entrypoint total_supply() : ínt
```

| return | type |
| :--- | :--- |
| total_supply | int |

### balance\(\)

Returns the number of NFTs owned by the account with address `owner` in the contract. If the owner address is unknown to the contract, `None` will be returned. Using `option` type as a return value allows us to determine if the account owns 0, more than 0, or the account has never owned a balance and is still unknown to the contract.

```sophia
entrypoint balance(owner: address) : option(int)
```

| parameter | type |
| :--- | :--- |
| owner | address |

| return | type |
| :--- | :--- |
| balance | option(int) |

### owner\(\)

Returns the owner's address for the provided `token_id` if the NFT is minted. If the NFT isn't minted, `None` will be returned. 

```sophia
entrypoint owner(token_id: int) : option(address)
```

| parameter | type |
| :--- | :--- |
| token_id | int |

| return | type |
| :--- | :--- |
| owner | option(address) |

### transfer\(\)
Transfers NFT with ID `token_id` from the current owner to the `to` address. Will invoke `IAEX141Receiver.on_aex141_received` if the `to` address belongs to a contract. If provided, `data` will be submitted with the invocation of `IAEX141Receiver.on_aex141_received`. Emits the `Transfer` event.

Throws if:
- `Call.caller` is NOT the current owner or NOT approved to transfer on behalf of the owner;
- `token_id` is NOT a valid token;
- the invocation of `IAEX141Receiver.on_aex141_received` fails.

```sophia
stateful entrypoint transfer(to: address, token_id: int, data: option(string)) : unit
```

| parameter | type |
| :--- | :--- |
| to | address |
| token | int |
| data | option(string) |

### approve\(\)

Sets the `approved` address to interact on behalf of an owner for the NFT with ID `token_id`. If `enabled` is true the `operator` address is approved, if `false` the approval is revoked. Throws unless caller is the current NFT owner, or an authorized operator of the current owner. Emits the `Approval` event.

```sophia
stateful entrypoint approve(approved: address, token_id: int, enabled: bool) : unit
```

| parameter | type |
| :--- | :--- |
| approved | address |
| token_id | int |
| enabled | bool |

### approve_all\(\)

Enables or disables approval for an `operator` address to manage all of the caller's NFTs. If `enabled` is true, the `operator` address is approved, if `false`, the approval is revoked. Emits the `ApprovalForAll` event.

```sophia
stateful entrypoint approve_all(operator: address, enabled: bool) : unit
```

| parameter | type |
| :--- | :--- |
| operator | address |
| enabled | bool |

### get_approved\(\)

Returns the address approved to interact with the NFT with ID `token_id` or returns `None` if no approval has been set. Throws if NFT with ID `token_id` does not exist.

```sophia
entrypoint get_approved(token_id: int) : option(address)
``` 

| parameter | type |
| :--- | :--- |
| token_id | int |

| return | type |
| :--- | :--- |
| approved | option(address) |

### is_approved\(\)

Returns `true` if `approved` address is approved to transact for NFT with ID `token_id`.

```sophia
entrypoint is_approved(token_id: int, approved: address) : bool
``` 

| parameter | type |
| :--- | :--- |
| token_id | int |
| approved | address |

| return | type |
| :--- | :--- |
| approved | bool |
    
### is_approved_for_all\(\)

Returns `true` if `operator` is approved to commit transactions on behalf of `owner`.

Indicates whether an address is an authorized operator for another address.

```sophia
entrypoint is_approved_for_all(owner: address, operator: address) : bool
``` 

| parameter | type |
| :--- | :--- |
| owner | address |
| approved | address |

| return | type |
| :--- | :--- |
| approved | bool |
     
## Events

```sophia
datatype event 
        = Transfer(address, address, int)
        | Approval(address, address, int, string)
        | ApprovalForAll(address, address, string)
```

### *Transfer*

This event MUST be triggered and emitted when tokens are transferred.

The event arguments should be as follows: `(from, to, token_id)`

```sophia
Transfer(address, address, int)
```

| parameter | type |
| :--- | :--- |
| from | address |
| to | address |
| token_id | int |

### *Approval*

This event MUST be triggered and emitted upon approval, including revocation of approval.

The event arguments should be as follows: `(owner, approved, token_id, enabled)`.
Enabled is of type string, because of a limit of 3 on indexed values. Since address, int and bool are automatically indexed, having enabled as bool would cause an error, as it would be the 4th indexed item. Use `"true"` or `"false"` as return values instead.

```sophia
Approval(address, address, int, string)
```

| parameter | type |
| :--- | :--- |
| owner | address |
| approved | address |
| token_id | int |
| enabled | string |

### *ApprovalForAll*

This event MUST be triggered and emitted upon a change of operator status, including revocation of approval for all NFTs in the contract.

The event arguments should be as follows: `(owner, operator, approved)`

For idiomatic reasons `approved` is, just as with `Approval`, of type `string`

```sophia
ApprovalForAll(address, address, string)
```

| parameter | type |
| :--- | :--- |
| owner | address |
| operator | address |
| approved | string |

# Receiver contract interface

The standard only allows safe transfers of tokens. On transfer a check MUST be performed which checks if the recipient is a contract and if so the transfer MAY ONLY happen if `on_aex141_received` returns true.

## AEX141Receiver

```sophia
contract interface IAEX141Receiver = 
    entrypoint on_aex141_received : (option(address), int, option(string)) => bool
```

### on_aex141_received\(\)

Deals with receiving NFTs on behalf of a contract. Contracts MUST implement this interface to be able to receive NFTs. Mint and transfer transactions will invoke the `on_aex141_received` function.

Returns `true` or `false` to signal whether processing the received NFT was successful or not.

```sophia
entrypoint on_aex141_received(from: option(address), token_id: int, data: option(string)) : bool
```
| parameter | type |
| :--- | :--- |
| from | option(address) |
| token_id | int |
| data | option(string) |

# Extensions

This section covers the extendability of the basic token - e.g. mintable, burnable.

When an NFT contract implements an extension its name should be included in the `aex141_extensions` array, in order for third party software or contracts to know the interface.
Any extensions should be implementable without permission. Developers of extensions MUST choose a name for `aex141_extensions` that is not yet used. Developers CAN make a pull request to the reference implementation for general purpose extensions and maintainers choose to eventually include them.

## Extension Mintable ("mintable")

The `mintable` extension SHOULD be used for generic NFT minting without specific requirements in regards to minting.

### mint\(\)

Issues a new token to the provided address. If the `owner` is a contract, `IAEX141Receiver.on_aex141_received` will be called with `data` if provided.

Emits the `Mint` event.

Throws if the call to `IAEX141Receiver.on_aex141_received` implementation failed (safe transfer)

```sophia
stateful entrypoint mint(owner: address, metadata: option(metadata), data: option(string)) : int
```

| parameter | type |
| :--- | :--- |
| owner | address |
| metadata | option(metadata) |
| data  | option(string) |

| return | type |
| :--- | :--- |
| token_id | int |

## Extension Burnable ("burnable")

The `burnable` extension SHOULD be used if NFTs within a contract are intended to be burnable.

### burn\(\)

Burns the NFT with the provided `token_id`.

Emits the `Burn` event.

Throws if `Call.caller` is NOT the current owner or NOT approved to transfer on behalf of the owner.

```sophia
stateful entrypoint burn(token_id: int) : unit
```

| parameter | type |
| :--- | :--- |
| token_id | int |

## Extension Events

**Mint**

This event MUST be triggered whenever a new token is minted with the `mintable` extension.

The event arguments should be as follows: `(to, token_id)`

```sophia
Mint(address, int)
```

| parameter | type |
| :--- | :--- |
| to | address |
| token_id | int |

**Burn**

This event MUST be triggered whenever an NFT is burned.

The burn event arguments should be as follows: `(owner, token_id)`

```sophia
Burn(address, int)
```

| parameter | type |
| :--- | :--- |
| owner | address |
| token_id | int |
